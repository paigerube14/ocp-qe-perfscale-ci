{"openapi":"3.0.0","info":{"description":"OpenShift provides builds, application lifecycle, image content management,\nand administrative policy on top of Kubernetes. The API allows consistent\nmanagement of those objects.\n\nAll API operations are authenticated via an Authorization\tbearer token that\nis provided for service accounts as a generated secret (in JWT form) or via\nthe native OAuth endpoint located at /oauth/authorize. Core infrastructure\ncomponents may use client certificates that require no authentication.\n\nAll API operations return a 'resourceVersion' string that represents the\nversion of the object in the underlying storage. The standard LIST operation\nperforms a snapshot read of the underlying objects, returning a resourceVersion\nrepresenting a consistent version of the listed objects. The WATCH operation\nallows all updates to a set of objects after the provided resourceVersion to\nbe observed by a client. By listing and beginning a watch from the returned\nresourceVersion, clients may observe a consistent view of the state of one\nor more objects. Note that WATCH always returns the update after the provided\nresourceVersion. Watch may be extended a limited time in the past - using\netcd 2 the watch window is 1000 events (which on a large cluster may only\nbe a few tens of seconds) so clients must explicitly handle the \"watch\nto old error\" by re-listing.\n\nObjects are divided into two rough categories - those that have a lifecycle\nand must reflect the state of the cluster, and those that have no state.\nObjects with lifecycle typically have three main sections:\n\n* 'metadata' common to all objects\n* a 'spec' that represents the desired state\n* a 'status' that represents how much of the desired state is reflected on\n  the cluster at the current time\n\nObjects that have no state have 'metadata' but may lack a 'spec' or 'status'\nsection.\n\nObjects are divided into those that are namespace scoped (only exist inside\nof a namespace) and those that are cluster scoped (exist outside of\na namespace). A namespace scoped resource will be deleted when the namespace\nis deleted and cannot be created if the namespace has not yet been created\nor is in the process of deletion. Cluster scoped resources are typically\nonly accessible to admins - resources like nodes, persistent volumes, and\ncluster policy.\n\nAll objects have a schema that is a combination of the 'kind' and\n'apiVersion' fields. This schema is additive only for any given version -\nno backwards incompatible changes are allowed without incrementing the\napiVersion. The server will return and accept a number of standard\nresponses that share a common schema - for instance, the common\nerror type is 'metav1.Status' (described below) and will be returned\non any error from the API server.\n\nThe API is available in multiple serialization formats - the default is\nJSON (Accept: application/json and Content-Type: application/json) but\nclients may also use YAML (application/yaml) or the native Protobuf\nschema (application/vnd.kubernetes.protobuf). Note that the format\nof the WATCH API call is slightly different - for JSON it returns newline\ndelimited objects while for Protobuf it returns length-delimited frames\n(4 bytes in network-order) that contain a 'versioned.Watch' Protobuf\nobject.\n\nSee the OpenShift documentation at https://docs.openshift.org for more\ninformation.\n","title":"OpenShift API (with Kubernetes)","license":{"name":"Apache 2.0 (ASL2.0)","url":"http://www.apache.org/licenses/LICENSE-2.0"},"version":"4.14.0-202307170931.p0.ge321623.assembly.stream-e321623"},"paths":{"/apis/build.openshift.io/v1/":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"get available resources","operationId":"getBuildOpenshiftIoV1APIResources","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList"}}}},"401":{"description":"Unauthorized"}}}},"/apis/build.openshift.io/v1/buildconfigs":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"list or watch objects of kind BuildConfig","operationId":"listBuildOpenshiftIoV1BuildConfigForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/builds":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"list or watch objects of kind Build","operationId":"listBuildOpenshiftIoV1BuildForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/buildconfigs":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"list or watch objects of kind BuildConfig","operationId":"listBuildOpenshiftIoV1NamespacedBuildConfig","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"post":{"tags":["buildOpenshiftIo_v1"],"description":"create a BuildConfig","operationId":"createBuildOpenshiftIoV1NamespacedBuildConfig","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"delete":{"tags":["buildOpenshiftIo_v1"],"description":"delete collection of BuildConfig","operationId":"deleteBuildOpenshiftIoV1CollectionNamespacedBuildConfig","parameters":[{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/buildconfigs/{name}":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"read the specified BuildConfig","operationId":"readBuildOpenshiftIoV1NamespacedBuildConfig","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"put":{"tags":["buildOpenshiftIo_v1"],"description":"replace the specified BuildConfig","operationId":"replaceBuildOpenshiftIoV1NamespacedBuildConfig","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"delete":{"tags":["buildOpenshiftIo_v1"],"description":"delete a BuildConfig","operationId":"deleteBuildOpenshiftIoV1NamespacedBuildConfig","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"patch":{"tags":["buildOpenshiftIo_v1"],"description":"partially update the specified BuildConfig","operationId":"patchBuildOpenshiftIoV1NamespacedBuildConfig","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/strategic-merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"parameters":[{"name":"name","in":"path","description":"name of the BuildConfig","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/buildconfigs/{name}/instantiate":{"post":{"tags":["buildOpenshiftIo_v1"],"description":"create instantiate of a BuildConfig","operationId":"createBuildOpenshiftIoV1NamespacedBuildConfigInstantiate","requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildRequest"}},"parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"name","in":"path","description":"name of the BuildRequest","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/buildconfigs/{name}/instantiatebinary":{"post":{"tags":["buildOpenshiftIo_v1"],"description":"connect POST requests to instantiatebinary of BuildConfig","operationId":"connectBuildOpenshiftIoV1PostNamespacedBuildConfigInstantiatebinary","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"connect","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BinaryBuildRequestOptions"}},"parameters":[{"name":"asFile","in":"query","description":"asFile determines if the binary should be created as a file within the source rather than extracted as an archive","schema":{"type":"string","uniqueItems":true}},{"name":"name","in":"path","description":"name of the BinaryBuildRequestOptions","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"revision.authorEmail","in":"query","description":"revision.authorEmail of the source control user","schema":{"type":"string","uniqueItems":true}},{"name":"revision.authorName","in":"query","description":"revision.authorName of the source control user","schema":{"type":"string","uniqueItems":true}},{"name":"revision.commit","in":"query","description":"revision.commit is the value identifying a specific commit","schema":{"type":"string","uniqueItems":true}},{"name":"revision.committerEmail","in":"query","description":"revision.committerEmail of the source control user","schema":{"type":"string","uniqueItems":true}},{"name":"revision.committerName","in":"query","description":"revision.committerName of the source control user","schema":{"type":"string","uniqueItems":true}},{"name":"revision.message","in":"query","description":"revision.message is the description of a specific commit","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/buildconfigs/{name}/webhooks":{"post":{"tags":["buildOpenshiftIo_v1"],"description":"connect POST requests to webhooks of BuildConfig","operationId":"connectBuildOpenshiftIoV1PostNamespacedBuildConfigWebhooks","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"string"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"connect","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"name","in":"path","description":"name of the Build","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"path","in":"query","description":"Path is the URL path to use for the current proxy request to pod.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/buildconfigs/{name}/webhooks/{path}":{"post":{"tags":["buildOpenshiftIo_v1"],"description":"connect POST requests to webhooks of BuildConfig","operationId":"connectBuildOpenshiftIoV1PostNamespacedBuildConfigWebhooksWithPath","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"string"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"connect","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"name","in":"path","description":"name of the Build","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"path","in":"path","description":"path to the resource","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"path","in":"query","description":"Path is the URL path to use for the current proxy request to pod.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/builds":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"list or watch objects of kind Build","operationId":"listBuildOpenshiftIoV1NamespacedBuild","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"post":{"tags":["buildOpenshiftIo_v1"],"description":"create a Build","operationId":"createBuildOpenshiftIoV1NamespacedBuild","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"delete":{"tags":["buildOpenshiftIo_v1"],"description":"delete collection of Build","operationId":"deleteBuildOpenshiftIoV1CollectionNamespacedBuild","parameters":[{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/builds/{name}":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"read the specified Build","operationId":"readBuildOpenshiftIoV1NamespacedBuild","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"put":{"tags":["buildOpenshiftIo_v1"],"description":"replace the specified Build","operationId":"replaceBuildOpenshiftIoV1NamespacedBuild","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"delete":{"tags":["buildOpenshiftIo_v1"],"description":"delete a Build","operationId":"deleteBuildOpenshiftIoV1NamespacedBuild","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"patch":{"tags":["buildOpenshiftIo_v1"],"description":"partially update the specified Build","operationId":"patchBuildOpenshiftIoV1NamespacedBuild","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/strategic-merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"name","in":"path","description":"name of the Build","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/builds/{name}/clone":{"post":{"tags":["buildOpenshiftIo_v1"],"description":"create clone of a Build","operationId":"createBuildOpenshiftIoV1NamespacedBuildClone","requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildRequest"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildRequest"}},"parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"name","in":"path","description":"name of the BuildRequest","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/builds/{name}/details":{"put":{"tags":["buildOpenshiftIo_v1"],"description":"replace details of the specified Build","operationId":"replaceBuildOpenshiftIoV1NamespacedBuildDetails","requestBody":{"content":{"*/*":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"name","in":"path","description":"name of the Build","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/build.openshift.io/v1/namespaces/{namespace}/builds/{name}/log":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"read log of the specified Build","operationId":"readBuildOpenshiftIoV1NamespacedBuildLog","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildLog"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildLog"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildLog"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildLog"}},"parameters":[{"name":"container","in":"query","description":"cointainer for which to stream logs. Defaults to only container if there is one container in the pod.","schema":{"type":"string","uniqueItems":true}},{"name":"follow","in":"query","description":"follow if true indicates that the build log should be streamed until the build terminates.","schema":{"type":"boolean","uniqueItems":true}},{"name":"insecureSkipTLSVerifyBackend","in":"query","description":"insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).","schema":{"type":"boolean","uniqueItems":true}},{"name":"limitBytes","in":"query","description":"limitBytes, If set, is the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.","schema":{"type":"integer","uniqueItems":true}},{"name":"name","in":"path","description":"name of the BuildLog","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"nowait","in":"query","description":"noWait if true causes the call to return immediately even if the build is not available yet. Otherwise the server will wait until the build has started.","schema":{"type":"boolean","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"previous","in":"query","description":"previous returns previous build logs. Defaults to false.","schema":{"type":"boolean","uniqueItems":true}},{"name":"sinceSeconds","in":"query","description":"sinceSeconds is a relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.","schema":{"type":"integer","uniqueItems":true}},{"name":"tailLines","in":"query","description":"tailLines, If set, is the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime","schema":{"type":"integer","uniqueItems":true}},{"name":"timestamps","in":"query","description":"timestamps, If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.","schema":{"type":"boolean","uniqueItems":true}},{"name":"version","in":"query","description":"version of the build for which to view logs.","schema":{"type":"integer","uniqueItems":true}}]},"/apis/build.openshift.io/v1/watch/buildconfigs":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"watch individual changes to a list of BuildConfig. deprecated: use the 'watch' parameter with a list operation instead.","operationId":"watchBuildOpenshiftIoV1BuildConfigListForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"watchlist","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/watch/builds":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"watch individual changes to a list of Build. deprecated: use the 'watch' parameter with a list operation instead.","operationId":"watchBuildOpenshiftIoV1BuildListForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"watchlist","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/watch/namespaces/{namespace}/buildconfigs":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"watch individual changes to a list of BuildConfig. deprecated: use the 'watch' parameter with a list operation instead.","operationId":"watchBuildOpenshiftIoV1NamespacedBuildConfigList","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"watchlist","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/watch/namespaces/{namespace}/buildconfigs/{name}":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"watch changes to an object of kind BuildConfig. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.","operationId":"watchBuildOpenshiftIoV1NamespacedBuildConfig","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"watch","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"BuildConfig"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"name","in":"path","description":"name of the BuildConfig","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/watch/namespaces/{namespace}/builds":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"watch individual changes to a list of Build. deprecated: use the 'watch' parameter with a list operation instead.","operationId":"watchBuildOpenshiftIoV1NamespacedBuildList","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"watchlist","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/build.openshift.io/v1/watch/namespaces/{namespace}/builds/{name}":{"get":{"tags":["buildOpenshiftIo_v1"],"description":"watch changes to an object of kind Build. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.","operationId":"watchBuildOpenshiftIoV1NamespacedBuild","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/json;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/vnd.kubernetes.protobuf;stream=watch":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"watch","x-kubernetes-group-version-kind":{"group":"build.openshift.io","version":"v1","kind":"Build"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"name","in":"path","description":"name of the Build","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]}},"components":{"schemas":{"com.github.openshift.api.build.v1.BinaryBuildSource":{"description":"BinaryBuildSource describes a binary file to be used for the Docker and Source build strategies, where the file will be extracted and used as the build source.","type":"object","properties":{"asFile":{"description":"asFile indicates that the provided binary input should be considered a single file within the build input. For example, specifying \"webapp.war\" would place the provided binary as `/webapp.war` for the builder. If left empty, the Docker and Source build strategies assume this file is a zip, tar, or tar.gz file and extract it as the source. The custom strategy receives this binary as standard input. This filename may not contain slashes or be '..' or '.'.","type":"string"}}},"com.github.openshift.api.build.v1.BitbucketWebHookCause":{"description":"BitbucketWebHookCause has information about a Bitbucket webhook that triggered a build.","type":"object","properties":{"revision":{"description":"Revision is the git source revision information of the trigger.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"secret":{"description":"Secret is the obfuscated webhook secret that triggered a build.","type":"string"}}},"com.github.openshift.api.build.v1.Build":{"description":"Build encapsulates the inputs needed to produce a new deployable image, as well as the status of the execution and a reference to the Pod which executed the build.\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"metadata is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"spec is all the inputs used to execute the build.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildSpec"}]},"status":{"description":"status is the current status of the build.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildStatus"}]}},"x-kubernetes-group-version-kind":[{"group":"","kind":"Build","version":"v1"},{"group":"build.openshift.io","kind":"Build","version":"v1"}]},"com.github.openshift.api.build.v1.BuildCondition":{"description":"BuildCondition describes the state of a build at a certain point.","type":"object","required":["type","status"],"properties":{"lastTransitionTime":{"description":"The last time the condition transitioned from one status to another.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"lastUpdateTime":{"description":"The last time this condition was updated.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"message":{"description":"A human readable message indicating details about the transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition.","type":"string"},"status":{"description":"Status of the condition, one of True, False, Unknown.","type":"string","default":""},"type":{"description":"Type of build condition.","type":"string","default":""}}},"com.github.openshift.api.build.v1.BuildConfig":{"description":"Build configurations define a build process for new container images. There are three types of builds possible - a container image build using a Dockerfile, a Source-to-Image build that uses a specially prepared base image that accepts source code that it can make runnable, and a custom build that can run // arbitrary container images as a base and accept the build parameters. Builds run on the cluster and on completion are pushed to the container image registry specified in the \"output\" section. A build can be triggered via a webhook, when the base image changes, or when a user manually requests a new build be // created.\n\nEach build created by a build configuration is numbered and refers back to its parent configuration. Multiple builds can be triggered at once. Builds that do not have \"output\" set can be used to test code or run a verification build.\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","type":"object","required":["spec"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"metadata is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"spec holds all the input necessary to produce a new build, and the conditions when to trigger them.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigSpec"}]},"status":{"description":"status holds any relevant information about a build config","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfigStatus"}]}},"x-kubernetes-group-version-kind":[{"group":"","kind":"BuildConfig","version":"v1"},{"group":"build.openshift.io","kind":"BuildConfig","version":"v1"}]},"com.github.openshift.api.build.v1.BuildConfigList":{"description":"BuildConfigList is a collection of BuildConfigs.\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"items is a list of build configs","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildConfig"}]}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"metadata is the standard list's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"","kind":"BuildConfigList","version":"v1"},{"group":"build.openshift.io","kind":"BuildConfigList","version":"v1"}]},"com.github.openshift.api.build.v1.BuildConfigSpec":{"description":"BuildConfigSpec describes when and how builds are created","type":"object","required":["strategy"],"properties":{"completionDeadlineSeconds":{"description":"completionDeadlineSeconds is an optional duration in seconds, counted from the time when a build pod gets scheduled in the system, that the build may be active on a node before the system actively tries to terminate the build; value must be positive integer","type":"integer","format":"int64"},"failedBuildsHistoryLimit":{"description":"failedBuildsHistoryLimit is the number of old failed builds to retain. When a BuildConfig is created, the 5 most recent failed builds are retained unless this value is set. If removed after the BuildConfig has been created, all failed builds are retained.","type":"integer","format":"int32"},"mountTrustedCA":{"description":"mountTrustedCA bind mounts the cluster's trusted certificate authorities, as defined in the cluster's proxy configuration, into the build. This lets processes within a build trust components signed by custom PKI certificate authorities, such as private artifact repositories and HTTPS proxies.\n\nWhen this field is set to true, the contents of `/etc/pki/ca-trust` within the build are managed by the build container, and any changes to this directory or its subdirectories (for example - within a Dockerfile `RUN` instruction) are not persisted in the build's output image.","type":"boolean"},"nodeSelector":{"description":"nodeSelector is a selector which must be true for the build pod to fit on a node If nil, it can be overridden by default build nodeselector values for the cluster. If set to an empty map or a map with any values, default build nodeselector values are ignored.","type":"object","additionalProperties":{"type":"string","default":""}},"output":{"description":"output describes the container image the Strategy should produce.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildOutput"}]},"postCommit":{"description":"postCommit is a build hook executed after the build output image is committed, before it is pushed to a registry.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildPostCommitSpec"}]},"resources":{"description":"resources computes resource requirements to execute the build.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"}]},"revision":{"description":"revision is the information from the source for a specific repo snapshot. This is optional.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"runPolicy":{"description":"RunPolicy describes how the new build created from this build configuration will be scheduled for execution. This is optional, if not specified we default to \"Serial\".","type":"string"},"serviceAccount":{"description":"serviceAccount is the name of the ServiceAccount to use to run the pod created by this build. The pod will be allowed to use secrets referenced by the ServiceAccount","type":"string"},"source":{"description":"source describes the SCM in use.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildSource"}]},"strategy":{"description":"strategy defines how to perform a build.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildStrategy"}]},"successfulBuildsHistoryLimit":{"description":"successfulBuildsHistoryLimit is the number of old successful builds to retain. When a BuildConfig is created, the 5 most recent successful builds are retained unless this value is set. If removed after the BuildConfig has been created, all successful builds are retained.","type":"integer","format":"int32"},"triggers":{"description":"triggers determine how new Builds can be launched from a BuildConfig. If no triggers are defined, a new build can only occur as a result of an explicit client build creation.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildTriggerPolicy"}]}}}},"com.github.openshift.api.build.v1.BuildConfigStatus":{"description":"BuildConfigStatus contains current state of the build config object.","type":"object","required":["lastVersion"],"properties":{"imageChangeTriggers":{"description":"ImageChangeTriggers captures the runtime state of any ImageChangeTrigger specified in the BuildConfigSpec, including the value reconciled by the OpenShift APIServer for the lastTriggeredImageID. There is a single entry in this array for each image change trigger in spec. Each trigger status references the ImageStreamTag that acts as the source of the trigger.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageChangeTriggerStatus"}]}},"lastVersion":{"description":"lastVersion is used to inform about number of last triggered build.","type":"integer","format":"int64","default":0}}},"com.github.openshift.api.build.v1.BuildList":{"description":"BuildList is a collection of Builds.\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"items is a list of builds","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.Build"}]}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"metadata is the standard list's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"","kind":"BuildList","version":"v1"},{"group":"build.openshift.io","kind":"BuildList","version":"v1"}]},"com.github.openshift.api.build.v1.BuildLog":{"description":"BuildLog is the (unused) resource associated with the build log redirector\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"}},"x-kubernetes-group-version-kind":[{"group":"","kind":"BuildLog","version":"v1"},{"group":"build.openshift.io","kind":"BuildLog","version":"v1"}]},"com.github.openshift.api.build.v1.BuildOutput":{"description":"BuildOutput is input to a build strategy and describes the container image that the strategy should produce.","type":"object","properties":{"imageLabels":{"description":"imageLabels define a list of labels that are applied to the resulting image. If there are multiple labels with the same name then the last one in the list is used.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageLabel"}]}},"pushSecret":{"description":"PushSecret is the name of a Secret that would be used for setting up the authentication for executing the Docker push to authentication enabled Docker Registry (or Docker Hub).","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"to":{"description":"to defines an optional location to push the output of this build to. Kind must be one of 'ImageStreamTag' or 'DockerImage'. This value will be used to look up a container image repository to push to. In the case of an ImageStreamTag, the ImageStreamTag will be looked for in the namespace of the build unless Namespace is specified.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]}}},"com.github.openshift.api.build.v1.BuildPostCommitSpec":{"description":"A BuildPostCommitSpec holds a build post commit hook specification. The hook executes a command in a temporary container running the build output image, immediately after the last layer of the image is committed and before the image is pushed to a registry. The command is executed with the current working directory ($PWD) set to the image's WORKDIR.\n\nThe build will be marked as failed if the hook execution fails. It will fail if the script or command return a non-zero exit code, or if there is any other error related to starting the temporary container.\n\nThere are five different ways to configure the hook. As an example, all forms below are equivalent and will execute `rake test --verbose`.\n\n1. Shell script:\n\n\t   \"postCommit\": {\n\t     \"script\": \"rake test --verbose\",\n\t   }\n\n\tThe above is a convenient form which is equivalent to:\n\n\t   \"postCommit\": {\n\t     \"command\": [\"/bin/sh\", \"-ic\"],\n\t     \"args\":    [\"rake test --verbose\"]\n\t   }\n\n2. A command as the image entrypoint:\n\n\t   \"postCommit\": {\n\t     \"commit\": [\"rake\", \"test\", \"--verbose\"]\n\t   }\n\n\tCommand overrides the image entrypoint in the exec form, as documented in\n\tDocker: https://docs.docker.com/engine/reference/builder/#entrypoint.\n\n3. Pass arguments to the default entrypoint:\n\n\t       \"postCommit\": {\n\t\t\t      \"args\": [\"rake\", \"test\", \"--verbose\"]\n\t\t      }\n\n\t    This form is only useful if the image entrypoint can handle arguments.\n\n4. Shell script with arguments:\n\n\t   \"postCommit\": {\n\t     \"script\": \"rake test $1\",\n\t     \"args\":   [\"--verbose\"]\n\t   }\n\n\tThis form is useful if you need to pass arguments that would otherwise be\n\thard to quote properly in the shell script. In the script, $0 will be\n\t\"/bin/sh\" and $1, $2, etc, are the positional arguments from Args.\n\n5. Command with arguments:\n\n\t   \"postCommit\": {\n\t     \"command\": [\"rake\", \"test\"],\n\t     \"args\":    [\"--verbose\"]\n\t   }\n\n\tThis form is equivalent to appending the arguments to the Command slice.\n\nIt is invalid to provide both Script and Command simultaneously. If none of the fields are specified, the hook is not executed.","type":"object","properties":{"args":{"description":"args is a list of arguments that are provided to either Command, Script or the container image's default entrypoint. The arguments are placed immediately after the command to be run.","type":"array","items":{"type":"string","default":""}},"command":{"description":"command is the command to run. It may not be specified with Script. This might be needed if the image doesn't have `/bin/sh`, or if you do not want to use a shell. In all other cases, using Script might be more convenient.","type":"array","items":{"type":"string","default":""}},"script":{"description":"script is a shell script to be run with `/bin/sh -ic`. It may not be specified with Command. Use Script when a shell script is appropriate to execute the post build hook, for example for running unit tests with `rake test`. If you need control over the image entrypoint, or if the image does not have `/bin/sh`, use Command and/or Args. The `-i` flag is needed to support CentOS and RHEL images that use Software Collections (SCL), in order to have the appropriate collections enabled in the shell. E.g., in the Ruby image, this is necessary to make `ruby`, `bundle` and other binaries available in the PATH.","type":"string"}}},"com.github.openshift.api.build.v1.BuildRequest":{"description":"BuildRequest is the resource used to pass parameters to build generator\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"binary":{"description":"binary indicates a request to build from a binary provided to the builder","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BinaryBuildSource"}]},"dockerStrategyOptions":{"description":"DockerStrategyOptions contains additional docker-strategy specific options for the build","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.DockerStrategyOptions"}]},"env":{"description":"env contains additional environment variables you want to pass into a builder container.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"from":{"description":"from is the reference to the ImageStreamTag that triggered the build.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"lastVersion":{"description":"lastVersion (optional) is the LastVersion of the BuildConfig that was used to generate the build. If the BuildConfig in the generator doesn't match, a build will not be generated.","type":"integer","format":"int64"},"metadata":{"description":"metadata is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"revision":{"description":"revision is the information from the source for a specific repo snapshot.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"sourceStrategyOptions":{"description":"SourceStrategyOptions contains additional source-strategy specific options for the build","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceStrategyOptions"}]},"triggeredBy":{"description":"triggeredBy describes which triggers started the most recent update to the build configuration and contains information about those triggers.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildTriggerCause"}]}},"triggeredByImage":{"description":"triggeredByImage is the Image that triggered this build.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]}},"x-kubernetes-group-version-kind":[{"group":"","kind":"BuildRequest","version":"v1"},{"group":"build.openshift.io","kind":"BuildRequest","version":"v1"}]},"com.github.openshift.api.build.v1.BuildSource":{"description":"BuildSource is the SCM used for the build.","type":"object","properties":{"binary":{"description":"binary builds accept a binary as their input. The binary is generally assumed to be a tar, gzipped tar, or zip file depending on the strategy. For container image builds, this is the build context and an optional Dockerfile may be specified to override any Dockerfile in the build context. For Source builds, this is assumed to be an archive as described above. For Source and container image builds, if binary.asFile is set the build will receive a directory with a single file. contextDir may be used when an archive is provided. Custom builds will receive this binary as input on STDIN.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BinaryBuildSource"}]},"configMaps":{"description":"configMaps represents a list of configMaps and their destinations that will be used for the build.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ConfigMapBuildSource"}]}},"contextDir":{"description":"contextDir specifies the sub-directory where the source code for the application exists. This allows to have buildable sources in directory other than root of repository.","type":"string"},"dockerfile":{"description":"dockerfile is the raw contents of a Dockerfile which should be built. When this option is specified, the FROM may be modified based on your strategy base image and additional ENV stanzas from your strategy environment will be added after the FROM, but before the rest of your Dockerfile stanzas. The Dockerfile source type may be used with other options like git - in those cases the Git repo will have any innate Dockerfile replaced in the context dir.","type":"string"},"git":{"description":"git contains optional information about git build source","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.GitBuildSource"}]},"images":{"description":"images describes a set of images to be used to provide source for the build","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageSource"}]}},"secrets":{"description":"secrets represents a list of secrets and their destinations that will be used only for the build.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SecretBuildSource"}]}},"sourceSecret":{"description":"sourceSecret is the name of a Secret that would be used for setting up the authentication for cloning private repository. The secret contains valid credentials for remote repository, where the data's key represent the authentication method to be used and value is the base64 encoded credentials. Supported auth methods are: ssh-privatekey.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"type":{"description":"type of build input to accept","type":"string"}}},"com.github.openshift.api.build.v1.BuildSpec":{"description":"BuildSpec has the information to represent a build and also additional information about a build","type":"object","required":["strategy"],"properties":{"completionDeadlineSeconds":{"description":"completionDeadlineSeconds is an optional duration in seconds, counted from the time when a build pod gets scheduled in the system, that the build may be active on a node before the system actively tries to terminate the build; value must be positive integer","type":"integer","format":"int64"},"mountTrustedCA":{"description":"mountTrustedCA bind mounts the cluster's trusted certificate authorities, as defined in the cluster's proxy configuration, into the build. This lets processes within a build trust components signed by custom PKI certificate authorities, such as private artifact repositories and HTTPS proxies.\n\nWhen this field is set to true, the contents of `/etc/pki/ca-trust` within the build are managed by the build container, and any changes to this directory or its subdirectories (for example - within a Dockerfile `RUN` instruction) are not persisted in the build's output image.","type":"boolean"},"nodeSelector":{"description":"nodeSelector is a selector which must be true for the build pod to fit on a node If nil, it can be overridden by default build nodeselector values for the cluster. If set to an empty map or a map with any values, default build nodeselector values are ignored.","type":"object","additionalProperties":{"type":"string","default":""}},"output":{"description":"output describes the container image the Strategy should produce.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildOutput"}]},"postCommit":{"description":"postCommit is a build hook executed after the build output image is committed, before it is pushed to a registry.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildPostCommitSpec"}]},"resources":{"description":"resources computes resource requirements to execute the build.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"}]},"revision":{"description":"revision is the information from the source for a specific repo snapshot. This is optional.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"serviceAccount":{"description":"serviceAccount is the name of the ServiceAccount to use to run the pod created by this build. The pod will be allowed to use secrets referenced by the ServiceAccount","type":"string"},"source":{"description":"source describes the SCM in use.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildSource"}]},"strategy":{"description":"strategy defines how to perform a build.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildStrategy"}]},"triggeredBy":{"description":"triggeredBy describes which triggers started the most recent update to the build configuration and contains information about those triggers.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildTriggerCause"}]}}}},"com.github.openshift.api.build.v1.BuildStatus":{"description":"BuildStatus contains the status of a build","type":"object","required":["phase"],"properties":{"cancelled":{"description":"cancelled describes if a cancel event was triggered for the build.","type":"boolean"},"completionTimestamp":{"description":"completionTimestamp is a timestamp representing the server time when this Build was finished, whether that build failed or succeeded.  It reflects the time at which the Pod running the Build terminated. It is represented in RFC3339 form and is in UTC.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"conditions":{"description":"Conditions represents the latest available observations of a build's current state.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildCondition"}]},"x-kubernetes-patch-merge-key":"type","x-kubernetes-patch-strategy":"merge"},"config":{"description":"config is an ObjectReference to the BuildConfig this Build is based on.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"duration":{"description":"duration contains time.Duration object describing build time.","type":"integer","format":"int64"},"logSnippet":{"description":"logSnippet is the last few lines of the build log.  This value is only set for builds that failed.","type":"string"},"message":{"description":"message is a human-readable message indicating details about why the build has this status.","type":"string"},"output":{"description":"output describes the container image the build has produced.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildStatusOutput"}]},"outputDockerImageReference":{"description":"outputDockerImageReference contains a reference to the container image that will be built by this build. Its value is computed from Build.Spec.Output.To, and should include the registry address, so that it can be used to push and pull the image.","type":"string"},"phase":{"description":"phase is the point in the build lifecycle. Possible values are \"New\", \"Pending\", \"Running\", \"Complete\", \"Failed\", \"Error\", and \"Cancelled\".","type":"string","default":""},"reason":{"description":"reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI.","type":"string"},"stages":{"description":"stages contains details about each stage that occurs during the build including start time, duration (in milliseconds), and the steps that occured within each stage.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.StageInfo"}]}},"startTimestamp":{"description":"startTimestamp is a timestamp representing the server time when this Build started running in a Pod. It is represented in RFC3339 form and is in UTC.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]}}},"com.github.openshift.api.build.v1.BuildStatusOutput":{"description":"BuildStatusOutput contains the status of the built image.","type":"object","properties":{"to":{"description":"to describes the status of the built image being pushed to a registry.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildStatusOutputTo"}]}}},"com.github.openshift.api.build.v1.BuildStatusOutputTo":{"description":"BuildStatusOutputTo describes the status of the built image with regards to image registry to which it was supposed to be pushed.","type":"object","properties":{"imageDigest":{"description":"imageDigest is the digest of the built container image. The digest uniquely identifies the image in the registry to which it was pushed.\n\nPlease note that this field may not always be set even if the push completes successfully - e.g. when the registry returns no digest or returns it in a format that the builder doesn't understand.","type":"string"}}},"com.github.openshift.api.build.v1.BuildStrategy":{"description":"BuildStrategy contains the details of how to perform a build.","type":"object","properties":{"customStrategy":{"description":"customStrategy holds the parameters to the Custom build strategy","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.CustomBuildStrategy"}]},"dockerStrategy":{"description":"dockerStrategy holds the parameters to the container image build strategy.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.DockerBuildStrategy"}]},"jenkinsPipelineStrategy":{"description":"JenkinsPipelineStrategy holds the parameters to the Jenkins Pipeline build strategy. Deprecated: use OpenShift Pipelines","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.JenkinsPipelineBuildStrategy"}]},"sourceStrategy":{"description":"sourceStrategy holds the parameters to the Source build strategy.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceBuildStrategy"}]},"type":{"description":"type is the kind of build strategy.","type":"string"}}},"com.github.openshift.api.build.v1.BuildTriggerCause":{"description":"BuildTriggerCause holds information about a triggered build. It is used for displaying build trigger data for each build and build configuration in oc describe. It is also used to describe which triggers led to the most recent update in the build configuration.","type":"object","properties":{"bitbucketWebHook":{"description":"BitbucketWebHook represents data for a Bitbucket webhook that fired a specific build.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BitbucketWebHookCause"}]},"genericWebHook":{"description":"genericWebHook holds data about a builds generic webhook trigger.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.GenericWebHookCause"}]},"githubWebHook":{"description":"gitHubWebHook represents data for a GitHub webhook that fired a specific build.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.GitHubWebHookCause"}]},"gitlabWebHook":{"description":"GitLabWebHook represents data for a GitLab webhook that fired a specific build.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.GitLabWebHookCause"}]},"imageChangeBuild":{"description":"imageChangeBuild stores information about an imagechange event that triggered a new build.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageChangeCause"}]},"message":{"description":"message is used to store a human readable message for why the build was triggered. E.g.: \"Manually triggered by user\", \"Configuration change\",etc.","type":"string"}}},"com.github.openshift.api.build.v1.BuildTriggerPolicy":{"description":"BuildTriggerPolicy describes a policy for a single trigger that results in a new Build.","type":"object","required":["type"],"properties":{"bitbucket":{"description":"BitbucketWebHook contains the parameters for a Bitbucket webhook type of trigger","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.WebHookTrigger"}]},"generic":{"description":"generic contains the parameters for a Generic webhook type of trigger","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.WebHookTrigger"}]},"github":{"description":"github contains the parameters for a GitHub webhook type of trigger","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.WebHookTrigger"}]},"gitlab":{"description":"GitLabWebHook contains the parameters for a GitLab webhook type of trigger","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.WebHookTrigger"}]},"imageChange":{"description":"imageChange contains parameters for an ImageChange type of trigger","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageChangeTrigger"}]},"type":{"description":"type is the type of build trigger. Valid values:\n\n- GitHub GitHubWebHookBuildTriggerType represents a trigger that launches builds on GitHub webhook invocations\n\n- Generic GenericWebHookBuildTriggerType represents a trigger that launches builds on generic webhook invocations\n\n- GitLab GitLabWebHookBuildTriggerType represents a trigger that launches builds on GitLab webhook invocations\n\n- Bitbucket BitbucketWebHookBuildTriggerType represents a trigger that launches builds on Bitbucket webhook invocations\n\n- ImageChange ImageChangeBuildTriggerType represents a trigger that launches builds on availability of a new version of an image\n\n- ConfigChange ConfigChangeBuildTriggerType will trigger a build on an initial build config creation WARNING: In the future the behavior will change to trigger a build on any config change","type":"string","default":""}}},"com.github.openshift.api.build.v1.BuildVolume":{"description":"BuildVolume describes a volume that is made available to build pods, such that it can be mounted into buildah's runtime environment. Only a subset of Kubernetes Volume sources are supported.","type":"object","required":["name","source","mounts"],"properties":{"mounts":{"description":"mounts represents the location of the volume in the image build container","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildVolumeMount"}]},"x-kubernetes-list-map-keys":["destinationPath"],"x-kubernetes-list-type":"map","x-kubernetes-patch-merge-key":"destinationPath","x-kubernetes-patch-strategy":"merge"},"name":{"description":"name is a unique identifier for this BuildVolume. It must conform to the Kubernetes DNS label standard and be unique within the pod. Names that collide with those added by the build controller will result in a failed build with an error message detailing which name caused the error. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","type":"string","default":""},"source":{"description":"source represents the location and type of the mounted volume.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildVolumeSource"}]}}},"com.github.openshift.api.build.v1.BuildVolumeMount":{"description":"BuildVolumeMount describes the mounting of a Volume within buildah's runtime environment.","type":"object","required":["destinationPath"],"properties":{"destinationPath":{"description":"destinationPath is the path within the buildah runtime environment at which the volume should be mounted. The transient mount within the build image and the backing volume will both be mounted read only. Must be an absolute path, must not contain '..' or ':', and must not collide with a destination path generated by the builder process Paths that collide with those added by the build controller will result in a failed build with an error message detailing which path caused the error.","type":"string","default":""}}},"com.github.openshift.api.build.v1.BuildVolumeSource":{"description":"BuildVolumeSource represents the source of a volume to mount Only one of its supported types may be specified at any given time.","type":"object","required":["type"],"properties":{"configMap":{"description":"configMap represents a ConfigMap that should populate this volume","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ConfigMapVolumeSource"}]},"csi":{"description":"csi represents ephemeral storage provided by external CSI drivers which support this capability","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.CSIVolumeSource"}]},"secret":{"description":"secret represents a Secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.SecretVolumeSource"}]},"type":{"description":"type is the BuildVolumeSourceType for the volume source. Type must match the populated volume source. Valid types are: Secret, ConfigMap","type":"string","default":""}}},"com.github.openshift.api.build.v1.ConfigMapBuildSource":{"description":"ConfigMapBuildSource describes a configmap and its destination directory that will be used only at the build time. The content of the configmap referenced here will be copied into the destination directory instead of mounting.","type":"object","required":["configMap"],"properties":{"configMap":{"description":"configMap is a reference to an existing configmap that you want to use in your build.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"destinationDir":{"description":"destinationDir is the directory where the files from the configmap should be available for the build time. For the Source build strategy, these will be injected into a container where the assemble script runs. For the container image build strategy, these will be copied into the build directory, where the Dockerfile is located, so users can ADD or COPY them during container image build.","type":"string"}}},"com.github.openshift.api.build.v1.CustomBuildStrategy":{"description":"CustomBuildStrategy defines input parameters specific to Custom build.","type":"object","required":["from"],"properties":{"buildAPIVersion":{"description":"buildAPIVersion is the requested API version for the Build object serialized and passed to the custom builder","type":"string"},"env":{"description":"env contains additional environment variables you want to pass into a builder container.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"exposeDockerSocket":{"description":"exposeDockerSocket will allow running Docker commands (and build container images) from inside the container.","type":"boolean"},"forcePull":{"description":"forcePull describes if the controller should configure the build pod to always pull the images for the builder or only pull if it is not present locally","type":"boolean"},"from":{"description":"from is reference to an DockerImage, ImageStreamTag, or ImageStreamImage from which the container image should be pulled","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"pullSecret":{"description":"pullSecret is the name of a Secret that would be used for setting up the authentication for pulling the container images from the private Docker registries","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"secrets":{"description":"secrets is a list of additional secrets that will be included in the build pod","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SecretSpec"}]}}}},"com.github.openshift.api.build.v1.DockerBuildStrategy":{"description":"DockerBuildStrategy defines input parameters specific to container image build.","type":"object","properties":{"buildArgs":{"description":"buildArgs contains build arguments that will be resolved in the Dockerfile.  See https://docs.docker.com/engine/reference/builder/#/arg for more details. NOTE: Only the 'name' and 'value' fields are supported. Any settings on the 'valueFrom' field are ignored.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"dockerfilePath":{"description":"dockerfilePath is the path of the Dockerfile that will be used to build the container image, relative to the root of the context (contextDir). Defaults to `Dockerfile` if unset.","type":"string"},"env":{"description":"env contains additional environment variables you want to pass into a builder container.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"forcePull":{"description":"forcePull describes if the builder should pull the images from registry prior to building.","type":"boolean"},"from":{"description":"from is a reference to an DockerImage, ImageStreamTag, or ImageStreamImage which overrides the FROM image in the Dockerfile for the build. If the Dockerfile uses multi-stage builds, this will replace the image in the last FROM directive of the file.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"imageOptimizationPolicy":{"description":"imageOptimizationPolicy describes what optimizations the system can use when building images to reduce the final size or time spent building the image. The default policy is 'None' which means the final build image will be equivalent to an image created by the container image build API. The experimental policy 'SkipLayers' will avoid commiting new layers in between each image step, and will fail if the Dockerfile cannot provide compatibility with the 'None' policy. An additional experimental policy 'SkipLayersAndWarn' is the same as 'SkipLayers' but simply warns if compatibility cannot be preserved.","type":"string"},"noCache":{"description":"noCache if set to true indicates that the container image build must be executed with the --no-cache=true flag","type":"boolean"},"pullSecret":{"description":"pullSecret is the name of a Secret that would be used for setting up the authentication for pulling the container images from the private Docker registries","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"volumes":{"description":"volumes is a list of input volumes that can be mounted into the builds runtime environment. Only a subset of Kubernetes Volume sources are supported by builds. More info: https://kubernetes.io/docs/concepts/storage/volumes","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildVolume"}]},"x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map","x-kubernetes-patch-merge-key":"name","x-kubernetes-patch-strategy":"merge"}}},"com.github.openshift.api.build.v1.DockerStrategyOptions":{"description":"DockerStrategyOptions contains extra strategy options for container image builds","type":"object","properties":{"buildArgs":{"description":"Args contains any build arguments that are to be passed to Docker.  See https://docs.docker.com/engine/reference/builder/#/arg for more details","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"noCache":{"description":"noCache overrides the docker-strategy noCache option in the build config","type":"boolean"}}},"com.github.openshift.api.build.v1.GenericWebHookCause":{"description":"GenericWebHookCause holds information about a generic WebHook that triggered a build.","type":"object","properties":{"revision":{"description":"revision is an optional field that stores the git source revision information of the generic webhook trigger when it is available.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"secret":{"description":"secret is the obfuscated webhook secret that triggered a build.","type":"string"}}},"com.github.openshift.api.build.v1.GitBuildSource":{"description":"GitBuildSource defines the parameters of a Git SCM","type":"object","required":["uri"],"properties":{"httpProxy":{"description":"httpProxy is a proxy used to reach the git repository over http","type":"string"},"httpsProxy":{"description":"httpsProxy is a proxy used to reach the git repository over https","type":"string"},"noProxy":{"description":"noProxy is the list of domains for which the proxy should not be used","type":"string"},"ref":{"description":"ref is the branch/tag/ref to build.","type":"string"},"uri":{"description":"uri points to the source that will be built. The structure of the source will depend on the type of build to run","type":"string","default":""}}},"com.github.openshift.api.build.v1.GitHubWebHookCause":{"description":"GitHubWebHookCause has information about a GitHub webhook that triggered a build.","type":"object","properties":{"revision":{"description":"revision is the git revision information of the trigger.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"secret":{"description":"secret is the obfuscated webhook secret that triggered a build.","type":"string"}}},"com.github.openshift.api.build.v1.GitLabWebHookCause":{"description":"GitLabWebHookCause has information about a GitLab webhook that triggered a build.","type":"object","properties":{"revision":{"description":"Revision is the git source revision information of the trigger.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceRevision"}]},"secret":{"description":"Secret is the obfuscated webhook secret that triggered a build.","type":"string"}}},"com.github.openshift.api.build.v1.GitSourceRevision":{"description":"GitSourceRevision is the commit information from a git source for a build","type":"object","properties":{"author":{"description":"author is the author of a specific commit","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceControlUser"}]},"commit":{"description":"commit is the commit hash identifying a specific commit","type":"string"},"committer":{"description":"committer is the committer of a specific commit","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SourceControlUser"}]},"message":{"description":"message is the description of a specific commit","type":"string"}}},"com.github.openshift.api.build.v1.ImageChangeCause":{"description":"ImageChangeCause contains information about the image that triggered a build","type":"object","properties":{"fromRef":{"description":"fromRef contains detailed information about an image that triggered a build.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"imageID":{"description":"imageID is the ID of the image that triggered a new build.","type":"string"}}},"com.github.openshift.api.build.v1.ImageChangeTrigger":{"description":"ImageChangeTrigger allows builds to be triggered when an ImageStream changes","type":"object","properties":{"from":{"description":"from is a reference to an ImageStreamTag that will trigger a build when updated It is optional. If no From is specified, the From image from the build strategy will be used. Only one ImageChangeTrigger with an empty From reference is allowed in a build configuration.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"lastTriggeredImageID":{"description":"lastTriggeredImageID is used internally by the ImageChangeController to save last used image ID for build This field is deprecated and will be removed in a future release. Deprecated","type":"string"},"paused":{"description":"paused is true if this trigger is temporarily disabled. Optional.","type":"boolean"}}},"com.github.openshift.api.build.v1.ImageChangeTriggerStatus":{"description":"ImageChangeTriggerStatus tracks the latest resolved status of the associated ImageChangeTrigger policy specified in the BuildConfigSpec.Triggers struct.","type":"object","properties":{"from":{"description":"from is the ImageStreamTag that is the source of the trigger.","default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageStreamTagReference"}]},"lastTriggerTime":{"description":"lastTriggerTime is the last time this particular ImageStreamTag triggered a Build to start. This field is only updated when this trigger specifically started a Build.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"lastTriggeredImageID":{"description":"lastTriggeredImageID represents the sha/id of the ImageStreamTag when a Build for this BuildConfig was started. The lastTriggeredImageID is updated each time a Build for this BuildConfig is started, even if this ImageStreamTag is not the reason the Build is started.","type":"string"}}},"com.github.openshift.api.build.v1.ImageLabel":{"description":"ImageLabel represents a label applied to the resulting image.","type":"object","required":["name"],"properties":{"name":{"description":"name defines the name of the label. It must have non-zero length.","type":"string","default":""},"value":{"description":"value defines the literal value of the label.","type":"string"}}},"com.github.openshift.api.build.v1.ImageSource":{"description":"ImageSource is used to describe build source that will be extracted from an image or used during a multi stage build. A reference of type ImageStreamTag, ImageStreamImage or DockerImage may be used. A pull secret can be specified to pull the image from an external registry or override the default service account secret if pulling from the internal registry. Image sources can either be used to extract content from an image and place it into the build context along with the repository source, or used directly during a multi-stage container image build to allow content to be copied without overwriting the contents of the repository source (see the 'paths' and 'as' fields).","type":"object","required":["from"],"properties":{"as":{"description":"A list of image names that this source will be used in place of during a multi-stage container image build. For instance, a Dockerfile that uses \"COPY --from=nginx:latest\" will first check for an image source that has \"nginx:latest\" in this field before attempting to pull directly. If the Dockerfile does not reference an image source it is ignored. This field and paths may both be set, in which case the contents will be used twice.","type":"array","items":{"type":"string","default":""}},"from":{"description":"from is a reference to an ImageStreamTag, ImageStreamImage, or DockerImage to copy source from.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"paths":{"description":"paths is a list of source and destination paths to copy from the image. This content will be copied into the build context prior to starting the build. If no paths are set, the build context will not be altered.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.ImageSourcePath"}]}},"pullSecret":{"description":"pullSecret is a reference to a secret to be used to pull the image from a registry If the image is pulled from the OpenShift registry, this field does not need to be set.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]}}},"com.github.openshift.api.build.v1.ImageSourcePath":{"description":"ImageSourcePath describes a path to be copied from a source image and its destination within the build directory.","type":"object","required":["sourcePath","destinationDir"],"properties":{"destinationDir":{"description":"destinationDir is the relative directory within the build directory where files copied from the image are placed.","type":"string","default":""},"sourcePath":{"description":"sourcePath is the absolute path of the file or directory inside the image to copy to the build directory.  If the source path ends in /. then the content of the directory will be copied, but the directory itself will not be created at the destination.","type":"string","default":""}}},"com.github.openshift.api.build.v1.ImageStreamTagReference":{"description":"ImageStreamTagReference references the ImageStreamTag in an image change trigger by namespace and name.","type":"object","properties":{"name":{"description":"name is the name of the ImageStreamTag for an ImageChangeTrigger","type":"string"},"namespace":{"description":"namespace is the namespace where the ImageStreamTag for an ImageChangeTrigger is located","type":"string"}}},"com.github.openshift.api.build.v1.JenkinsPipelineBuildStrategy":{"description":"JenkinsPipelineBuildStrategy holds parameters specific to a Jenkins Pipeline build. Deprecated: use OpenShift Pipelines","type":"object","properties":{"env":{"description":"env contains additional environment variables you want to pass into a build pipeline.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"jenkinsfile":{"description":"Jenkinsfile defines the optional raw contents of a Jenkinsfile which defines a Jenkins pipeline build.","type":"string"},"jenkinsfilePath":{"description":"JenkinsfilePath is the optional path of the Jenkinsfile that will be used to configure the pipeline relative to the root of the context (contextDir). If both JenkinsfilePath \u0026 Jenkinsfile are both not specified, this defaults to Jenkinsfile in the root of the specified contextDir.","type":"string"}}},"com.github.openshift.api.build.v1.SecretBuildSource":{"description":"SecretBuildSource describes a secret and its destination directory that will be used only at the build time. The content of the secret referenced here will be copied into the destination directory instead of mounting.","type":"object","required":["secret"],"properties":{"destinationDir":{"description":"destinationDir is the directory where the files from the secret should be available for the build time. For the Source build strategy, these will be injected into a container where the assemble script runs. Later, when the script finishes, all files injected will be truncated to zero length. For the container image build strategy, these will be copied into the build directory, where the Dockerfile is located, so users can ADD or COPY them during container image build.","type":"string"},"secret":{"description":"secret is a reference to an existing secret that you want to use in your build.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]}}},"com.github.openshift.api.build.v1.SecretLocalReference":{"description":"SecretLocalReference contains information that points to the local secret being used","type":"object","required":["name"],"properties":{"name":{"description":"Name is the name of the resource in the same namespace being referenced","type":"string","default":""}}},"com.github.openshift.api.build.v1.SecretSpec":{"description":"SecretSpec specifies a secret to be included in a build pod and its corresponding mount point","type":"object","required":["secretSource","mountPath"],"properties":{"mountPath":{"description":"mountPath is the path at which to mount the secret","type":"string","default":""},"secretSource":{"description":"secretSource is a reference to the secret","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]}}},"com.github.openshift.api.build.v1.SourceBuildStrategy":{"description":"SourceBuildStrategy defines input parameters specific to an Source build.","type":"object","required":["from"],"properties":{"env":{"description":"env contains additional environment variables you want to pass into a builder container.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVar"}]}},"forcePull":{"description":"forcePull describes if the builder should pull the images from registry prior to building.","type":"boolean"},"from":{"description":"from is reference to an DockerImage, ImageStreamTag, or ImageStreamImage from which the container image should be pulled","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectReference"}]},"incremental":{"description":"incremental flag forces the Source build to do incremental builds if true.","type":"boolean"},"pullSecret":{"description":"pullSecret is the name of a Secret that would be used for setting up the authentication for pulling the container images from the private Docker registries","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"scripts":{"description":"scripts is the location of Source scripts","type":"string"},"volumes":{"description":"volumes is a list of input volumes that can be mounted into the builds runtime environment. Only a subset of Kubernetes Volume sources are supported by builds. More info: https://kubernetes.io/docs/concepts/storage/volumes","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.BuildVolume"}]},"x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map","x-kubernetes-patch-merge-key":"name","x-kubernetes-patch-strategy":"merge"}}},"com.github.openshift.api.build.v1.SourceControlUser":{"description":"SourceControlUser defines the identity of a user of source control","type":"object","properties":{"email":{"description":"email of the source control user","type":"string"},"name":{"description":"name of the source control user","type":"string"}}},"com.github.openshift.api.build.v1.SourceRevision":{"description":"SourceRevision is the revision or commit information from the source for the build","type":"object","required":["type"],"properties":{"git":{"description":"Git contains information about git-based build source","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.GitSourceRevision"}]},"type":{"description":"type of the build source, may be one of 'Source', 'Dockerfile', 'Binary', or 'Images'","type":"string","default":""}}},"com.github.openshift.api.build.v1.SourceStrategyOptions":{"description":"SourceStrategyOptions contains extra strategy options for Source builds","type":"object","properties":{"incremental":{"description":"incremental overrides the source-strategy incremental option in the build config","type":"boolean"}}},"com.github.openshift.api.build.v1.StageInfo":{"description":"StageInfo contains details about a build stage.","type":"object","properties":{"durationMilliseconds":{"description":"durationMilliseconds identifies how long the stage took to complete in milliseconds. Note: the duration of a stage can exceed the sum of the duration of the steps within the stage as not all actions are accounted for in explicit build steps.","type":"integer","format":"int64"},"name":{"description":"name is a unique identifier for each build stage that occurs.","type":"string"},"startTime":{"description":"startTime is a timestamp representing the server time when this Stage started. It is represented in RFC3339 form and is in UTC.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"steps":{"description":"steps contains details about each step that occurs during a build stage including start time and duration in milliseconds.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.StepInfo"}]}}}},"com.github.openshift.api.build.v1.StepInfo":{"description":"StepInfo contains details about a build step.","type":"object","properties":{"durationMilliseconds":{"description":"durationMilliseconds identifies how long the step took to complete in milliseconds.","type":"integer","format":"int64"},"name":{"description":"name is a unique identifier for each build step.","type":"string"},"startTime":{"description":"startTime is a timestamp representing the server time when this Step started. it is represented in RFC3339 form and is in UTC.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]}}},"com.github.openshift.api.build.v1.WebHookTrigger":{"description":"WebHookTrigger is a trigger that gets invoked using a webhook type of post","type":"object","properties":{"allowEnv":{"description":"allowEnv determines whether the webhook can set environment variables; can only be set to true for GenericWebHook.","type":"boolean"},"secret":{"description":"secret used to validate requests. Deprecated: use SecretReference instead.","type":"string"},"secretReference":{"description":"secretReference is a reference to a secret in the same namespace, containing the value to be validated when the webhook is invoked. The secret being referenced must contain a key named \"WebHookSecretKey\", the value of which will be checked against the value supplied in the webhook invocation.","allOf":[{"$ref":"#/components/schemas/com.github.openshift.api.build.v1.SecretLocalReference"}]}}},"io.k8s.api.core.v1.CSIVolumeSource":{"description":"Represents a source location of a volume to mount, managed by an external CSI driver","type":"object","required":["driver"],"properties":{"driver":{"description":"driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.","type":"string","default":""},"fsType":{"description":"fsType to mount. Ex. \"ext4\", \"xfs\", \"ntfs\". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.","type":"string"},"nodePublishSecretRef":{"description":"nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"}]},"readOnly":{"description":"readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).","type":"boolean"},"volumeAttributes":{"description":"volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.","type":"object","additionalProperties":{"type":"string","default":""}}}},"io.k8s.api.core.v1.ConfigMapKeySelector":{"description":"Selects a key from a ConfigMap.","type":"object","required":["key"],"properties":{"key":{"description":"The key to select.","type":"string","default":""},"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","type":"string"},"optional":{"description":"Specify whether the ConfigMap or its key must be defined","type":"boolean"}},"x-kubernetes-map-type":"atomic"},"io.k8s.api.core.v1.ConfigMapVolumeSource":{"description":"Adapts a ConfigMap into a volume.\n\nThe contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.","type":"object","properties":{"defaultMode":{"description":"defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.","type":"integer","format":"int32"},"items":{"description":"items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.KeyToPath"}]}},"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","type":"string"},"optional":{"description":"optional specify whether the ConfigMap or its keys must be defined","type":"boolean"}}},"io.k8s.api.core.v1.EnvVar":{"description":"EnvVar represents an environment variable present in a Container.","type":"object","required":["name"],"properties":{"name":{"description":"Name of the environment variable. Must be a C_IDENTIFIER.","type":"string","default":""},"value":{"description":"Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".","type":"string"},"valueFrom":{"description":"Source for the environment variable's value. Cannot be used if value is not empty.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.EnvVarSource"}]}}},"io.k8s.api.core.v1.EnvVarSource":{"description":"EnvVarSource represents a source for the value of an EnvVar.","type":"object","properties":{"configMapKeyRef":{"description":"Selects a key of a ConfigMap.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ConfigMapKeySelector"}]},"fieldRef":{"description":"Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ObjectFieldSelector"}]},"resourceFieldRef":{"description":"Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ResourceFieldSelector"}]},"secretKeyRef":{"description":"Selects a key of a secret in the pod's namespace","allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.SecretKeySelector"}]}}},"io.k8s.api.core.v1.KeyToPath":{"description":"Maps a string key to a path within a volume.","type":"object","required":["key","path"],"properties":{"key":{"description":"key is the key to project.","type":"string","default":""},"mode":{"description":"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.","type":"integer","format":"int32"},"path":{"description":"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.","type":"string","default":""}}},"io.k8s.api.core.v1.LocalObjectReference":{"description":"LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.","type":"object","properties":{"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","type":"string"}},"x-kubernetes-map-type":"atomic"},"io.k8s.api.core.v1.ObjectFieldSelector":{"description":"ObjectFieldSelector selects an APIVersioned field of an object.","type":"object","required":["fieldPath"],"properties":{"apiVersion":{"description":"Version of the schema the FieldPath is written in terms of, defaults to \"v1\".","type":"string"},"fieldPath":{"description":"Path of the field to select in the specified API version.","type":"string","default":""}},"x-kubernetes-map-type":"atomic"},"io.k8s.api.core.v1.ObjectReference":{"description":"ObjectReference contains enough information to let you inspect or modify the referred object.","type":"object","properties":{"apiVersion":{"description":"API version of the referent.","type":"string"},"fieldPath":{"description":"If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.","type":"string"},"kind":{"description":"Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","type":"string"},"namespace":{"description":"Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/","type":"string"},"resourceVersion":{"description":"Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency","type":"string"},"uid":{"description":"UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids","type":"string"}},"x-kubernetes-map-type":"atomic"},"io.k8s.api.core.v1.ResourceClaim":{"description":"ResourceClaim references one entry in PodSpec.ResourceClaims.","type":"object","required":["name"],"properties":{"name":{"description":"Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.","type":"string","default":""}}},"io.k8s.api.core.v1.ResourceFieldSelector":{"description":"ResourceFieldSelector represents container resources (cpu, memory) and their output format","type":"object","required":["resource"],"properties":{"containerName":{"description":"Container name: required for volumes, optional for env vars","type":"string"},"divisor":{"description":"Specifies the output format of the exposed resources, defaults to \"1\"","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}]},"resource":{"description":"Required: resource to select","type":"string","default":""}},"x-kubernetes-map-type":"atomic"},"io.k8s.api.core.v1.ResourceRequirements":{"description":"ResourceRequirements describes the compute resource requirements.","type":"object","properties":{"claims":{"description":"Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.ResourceClaim"}]},"x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"description":"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object","additionalProperties":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}]}},"requests":{"description":"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object","additionalProperties":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}]}}}},"io.k8s.api.core.v1.SecretKeySelector":{"description":"SecretKeySelector selects a key of a Secret.","type":"object","required":["key"],"properties":{"key":{"description":"The key of the secret to select from.  Must be a valid secret key.","type":"string","default":""},"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","type":"string"},"optional":{"description":"Specify whether the Secret or its key must be defined","type":"boolean"}},"x-kubernetes-map-type":"atomic"},"io.k8s.api.core.v1.SecretVolumeSource":{"description":"Adapts a Secret into a volume.\n\nThe contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.","type":"object","properties":{"defaultMode":{"description":"defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.","type":"integer","format":"int32"},"items":{"description":"items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.core.v1.KeyToPath"}]}},"optional":{"description":"optional field specify whether the Secret or its keys must be defined","type":"boolean"},"secretName":{"description":"secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret","type":"string"}}},"io.k8s.apimachinery.pkg.api.resource.Quantity":{"description":"Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.\n\nThe serialization format is:\n\n``` \u003cquantity\u003e        ::= \u003csignedNumber\u003e\u003csuffix\u003e\n\n\t(Note that \u003csuffix\u003e may be empty, from the \"\" case in \u003cdecimalSI\u003e.)\n\n\u003cdigit\u003e           ::= 0 | 1 | ... | 9 \u003cdigits\u003e          ::= \u003cdigit\u003e | \u003cdigit\u003e\u003cdigits\u003e \u003cnumber\u003e          ::= \u003cdigits\u003e | \u003cdigits\u003e.\u003cdigits\u003e | \u003cdigits\u003e. | .\u003cdigits\u003e \u003csign\u003e            ::= \"+\" | \"-\" \u003csignedNumber\u003e    ::= \u003cnumber\u003e | \u003csign\u003e\u003cnumber\u003e \u003csuffix\u003e          ::= \u003cbinarySI\u003e | \u003cdecimalExponent\u003e | \u003cdecimalSI\u003e \u003cbinarySI\u003e        ::= Ki | Mi | Gi | Ti | Pi | Ei\n\n\t(International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)\n\n\u003cdecimalSI\u003e       ::= m | \"\" | k | M | G | T | P | E\n\n\t(Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)\n\n\u003cdecimalExponent\u003e ::= \"e\" \u003csignedNumber\u003e | \"E\" \u003csignedNumber\u003e ```\n\nNo matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.\n\nWhen a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.\n\nBefore serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:\n\n- No precision is lost - No fractional digits will be emitted - The exponent (or suffix) is as large as possible.\n\nThe sign will be omitted unless the number is negative.\n\nExamples:\n\n- 1.5 will be serialized as \"1500m\" - 1.5Gi will be serialized as \"1536Mi\"\n\nNote that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.\n\nNon-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)\n\nThis format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.","oneOf":[{"type":"string"},{"type":"number"}]},"io.k8s.apimachinery.pkg.apis.meta.v1.APIResource":{"description":"APIResource specifies the name of a resource and whether it is namespaced.","type":"object","required":["name","singularName","namespaced","kind","verbs"],"properties":{"categories":{"description":"categories is a list of the grouped resources this resource belongs to (e.g. 'all')","type":"array","items":{"type":"string","default":""}},"group":{"description":"group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale\".","type":"string"},"kind":{"description":"kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')","type":"string","default":""},"name":{"description":"name is the plural name of the resource.","type":"string","default":""},"namespaced":{"description":"namespaced indicates if a resource is namespaced or not.","type":"boolean","default":false},"shortNames":{"description":"shortNames is a list of suggested short names of the resource.","type":"array","items":{"type":"string","default":""}},"singularName":{"description":"singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface.","type":"string","default":""},"storageVersionHash":{"description":"The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates.","type":"string"},"verbs":{"description":"verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy)","type":"array","items":{"type":"string","default":""}},"version":{"description":"version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)\".","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList":{"description":"APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.","type":"object","required":["groupVersion","resources"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"groupVersion":{"description":"groupVersion is the group and version this APIResourceList is for.","type":"string","default":""},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"resources":{"description":"resources contains the name of the resources and if they are namespaced.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource"}]}}},"x-kubernetes-group-version-kind":[{"group":"","kind":"APIResourceList","version":"v1"}]},"io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions":{"description":"DeleteOptions may be provided when deleting an API object.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"dryRun":{"description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","type":"array","items":{"type":"string","default":""}},"gracePeriodSeconds":{"description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","type":"integer","format":"int64"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"orphanDependents":{"description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","type":"boolean"},"preconditions":{"description":"Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions"}]},"propagationPolicy":{"description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","type":"string"}},"x-kubernetes-group-version-kind":[{"group":"","kind":"DeleteOptions","version":"v1"},{"group":"admission.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"admission.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"admissionregistration.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"admissionregistration.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"admissionregistration.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"apiextensions.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"apiextensions.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"apiregistration.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"apiregistration.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"apps","kind":"DeleteOptions","version":"v1"},{"group":"apps","kind":"DeleteOptions","version":"v1beta1"},{"group":"apps","kind":"DeleteOptions","version":"v1beta2"},{"group":"apps.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"authentication.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"authentication.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"authentication.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"authorization.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"authorization.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"authorization.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"autoscaling","kind":"DeleteOptions","version":"v1"},{"group":"autoscaling","kind":"DeleteOptions","version":"v2"},{"group":"autoscaling","kind":"DeleteOptions","version":"v2beta1"},{"group":"autoscaling","kind":"DeleteOptions","version":"v2beta2"},{"group":"batch","kind":"DeleteOptions","version":"v1"},{"group":"batch","kind":"DeleteOptions","version":"v1beta1"},{"group":"build.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"certificates.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"certificates.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"certificates.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"coordination.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"coordination.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"discovery.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"discovery.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"events.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"events.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"extensions","kind":"DeleteOptions","version":"v1beta1"},{"group":"image.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"imagepolicy.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"networking.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"networking.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"networking.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"policy","kind":"DeleteOptions","version":"v1"},{"group":"policy","kind":"DeleteOptions","version":"v1beta1"},{"group":"project.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"quota.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"rbac.authorization.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"rbac.authorization.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"rbac.authorization.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"resource.k8s.io","kind":"DeleteOptions","version":"v1alpha2"},{"group":"route.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"scheduling.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"scheduling.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"scheduling.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"security.openshift.io","kind":"DeleteOptions","version":"v1"},{"group":"storage.k8s.io","kind":"DeleteOptions","version":"v1"},{"group":"storage.k8s.io","kind":"DeleteOptions","version":"v1alpha1"},{"group":"storage.k8s.io","kind":"DeleteOptions","version":"v1beta1"},{"group":"template.openshift.io","kind":"DeleteOptions","version":"v1"}]},"io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1":{"description":"FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.\n\nEach key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:\u003cname\u003e', where \u003cname\u003e is the name of a field in a struct, or key in a map 'v:\u003cvalue\u003e', where \u003cvalue\u003e is the exact json formatted value of a list item 'i:\u003cindex\u003e', where \u003cindex\u003e is position of a item in a list 'k:\u003ckeys\u003e', where \u003ckeys\u003e is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.\n\nThe exact format is defined in sigs.k8s.io/structured-merge-diff","type":"object"},"io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta":{"description":"ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.","type":"object","properties":{"continue":{"description":"continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.","type":"string"},"remainingItemCount":{"description":"remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.","type":"integer","format":"int64"},"resourceVersion":{"description":"String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency","type":"string"},"selfLink":{"description":"Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry":{"description":"ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.","type":"string"},"fieldsType":{"description":"FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"","type":"string"},"fieldsV1":{"description":"FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1"}]},"manager":{"description":"Manager is an identifier of the workflow managing these fields.","type":"string"},"operation":{"description":"Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.","type":"string"},"subresource":{"description":"Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.","type":"string"},"time":{"description":"Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]}}},"io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta":{"description":"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.","type":"object","properties":{"annotations":{"description":"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations","type":"object","additionalProperties":{"type":"string","default":""}},"creationTimestamp":{"description":"CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"deletionGracePeriodSeconds":{"description":"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.","type":"integer","format":"int64"},"deletionTimestamp":{"description":"DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"finalizers":{"description":"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.","type":"array","items":{"type":"string","default":""},"x-kubernetes-patch-strategy":"merge"},"generateName":{"description":"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency","type":"string"},"generation":{"description":"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.","type":"integer","format":"int64"},"labels":{"description":"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels","type":"object","additionalProperties":{"type":"string","default":""}},"managedFields":{"description":"ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"}]}},"name":{"description":"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names","type":"string"},"namespace":{"description":"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces","type":"string"},"ownerReferences":{"description":"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"}]},"x-kubernetes-patch-merge-key":"uid","x-kubernetes-patch-strategy":"merge"},"resourceVersion":{"description":"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency","type":"string"},"selfLink":{"description":"Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.","type":"string"},"uid":{"description":"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference":{"description":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","type":"object","required":["apiVersion","kind","name","uid"],"properties":{"apiVersion":{"description":"API version of the referent.","type":"string","default":""},"blockOwnerDeletion":{"description":"If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.","type":"boolean"},"controller":{"description":"If true, this reference points to the managing controller.","type":"boolean"},"kind":{"description":"Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string","default":""},"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names","type":"string","default":""},"uid":{"description":"UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids","type":"string","default":""}},"x-kubernetes-map-type":"atomic"},"io.k8s.apimachinery.pkg.apis.meta.v1.Patch":{"description":"Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.","type":"object"},"io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions":{"description":"Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.","type":"object","properties":{"resourceVersion":{"description":"Specifies the target ResourceVersion","type":"string"},"uid":{"description":"Specifies the target UID.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.Status":{"description":"Status is a return value for calls that don't return other objects.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"code":{"description":"Suggested HTTP return code for this status, 0 if not set.","type":"integer","format":"int32"},"details":{"description":"Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails"}]},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"message":{"description":"A human-readable description of the status of this operation.","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]},"reason":{"description":"A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.","type":"string"},"status":{"description":"Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","type":"string"}},"x-kubernetes-group-version-kind":[{"group":"","kind":"Status","version":"v1"},{"group":"resource.k8s.io","kind":"Status","version":"v1alpha2"}]},"io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause":{"description":"StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.","type":"object","properties":{"field":{"description":"The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"","type":"string"},"message":{"description":"A human-readable description of the cause of the error.  This field may be presented as-is to a reader.","type":"string"},"reason":{"description":"A machine-readable description of the cause of the error. If this value is empty there is no information available.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails":{"description":"StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.","type":"object","properties":{"causes":{"description":"The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"}]}},"group":{"description":"The group attribute of the resource associated with the status StatusReason.","type":"string"},"kind":{"description":"The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"name":{"description":"The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).","type":"string"},"retryAfterSeconds":{"description":"If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.","type":"integer","format":"int32"},"uid":{"description":"UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.Time":{"description":"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.","type":"string","format":"date-time"},"io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent":{"description":"Event represents a single event to a watched resource.","type":"object","required":["type","object"],"properties":{"object":{"description":"Object is:\n * If Type is Added or Modified: the new state of the object.\n * If Type is Deleted: the state of the object immediately before deletion.\n * If Type is Error: *Status is recommended; other types may make sense\n   depending on context.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.runtime.RawExtension"}]},"type":{"type":"string","default":""}},"x-kubernetes-group-version-kind":[{"group":"","kind":"WatchEvent","version":"v1"},{"group":"admission.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"admission.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"admissionregistration.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"admissionregistration.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"admissionregistration.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"apiextensions.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"apiextensions.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"apiregistration.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"apiregistration.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"apps","kind":"WatchEvent","version":"v1"},{"group":"apps","kind":"WatchEvent","version":"v1beta1"},{"group":"apps","kind":"WatchEvent","version":"v1beta2"},{"group":"apps.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"authentication.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"authentication.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"authentication.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"authorization.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"authorization.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"authorization.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"autoscaling","kind":"WatchEvent","version":"v1"},{"group":"autoscaling","kind":"WatchEvent","version":"v2"},{"group":"autoscaling","kind":"WatchEvent","version":"v2beta1"},{"group":"autoscaling","kind":"WatchEvent","version":"v2beta2"},{"group":"batch","kind":"WatchEvent","version":"v1"},{"group":"batch","kind":"WatchEvent","version":"v1beta1"},{"group":"build.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"certificates.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"certificates.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"certificates.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"coordination.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"coordination.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"discovery.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"discovery.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"events.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"events.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"extensions","kind":"WatchEvent","version":"v1beta1"},{"group":"image.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"imagepolicy.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"networking.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"networking.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"networking.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"policy","kind":"WatchEvent","version":"v1"},{"group":"policy","kind":"WatchEvent","version":"v1beta1"},{"group":"project.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"quota.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"rbac.authorization.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"rbac.authorization.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"rbac.authorization.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"resource.k8s.io","kind":"WatchEvent","version":"v1alpha2"},{"group":"route.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"scheduling.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"scheduling.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"scheduling.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"security.openshift.io","kind":"WatchEvent","version":"v1"},{"group":"storage.k8s.io","kind":"WatchEvent","version":"v1"},{"group":"storage.k8s.io","kind":"WatchEvent","version":"v1alpha1"},{"group":"storage.k8s.io","kind":"WatchEvent","version":"v1beta1"},{"group":"template.openshift.io","kind":"WatchEvent","version":"v1"}]},"io.k8s.apimachinery.pkg.runtime.RawExtension":{"description":"RawExtension is used to hold extensions in external versions.\n\nTo use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.\n\n// Internal package:\n\n\ttype MyAPIObject struct {\n\t\truntime.TypeMeta `json:\",inline\"`\n\t\tMyPlugin runtime.Object `json:\"myPlugin\"`\n\t}\n\n\ttype PluginA struct {\n\t\tAOption string `json:\"aOption\"`\n\t}\n\n// External package:\n\n\ttype MyAPIObject struct {\n\t\truntime.TypeMeta `json:\",inline\"`\n\t\tMyPlugin runtime.RawExtension `json:\"myPlugin\"`\n\t}\n\n\ttype PluginA struct {\n\t\tAOption string `json:\"aOption\"`\n\t}\n\n// On the wire, the JSON will look something like this:\n\n\t{\n\t\t\"kind\":\"MyAPIObject\",\n\t\t\"apiVersion\":\"v1\",\n\t\t\"myPlugin\": {\n\t\t\t\"kind\":\"PluginA\",\n\t\t\t\"aOption\":\"foo\",\n\t\t},\n\t}\n\nSo what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)","type":"object"}},"securitySchemes":{"BearerToken":{"type":"apiKey","description":"Bearer Token authentication","name":"authorization","in":"header"}}}}